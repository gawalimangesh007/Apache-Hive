--===================================================Schema creation for Input Data==============================================
Drop table eb_temp.stocks;
create table eb_temp.stocks(
date_ String,
Ticker String,
Open Double,
High Double,
Low Double,
Close Double,
Volume_for_the_day int) 
row format delimited fields terminated by ',';

--===================================================Seeing table structure==============================================
describe eb_temp.stocks;
col_name        data_type       comment
date_                   string
ticker                  string
open                    double
high                    double
low                     double
close                   double
volume_for_the_day      int

--===================================================Visualizing Data==============================================
Select * from eb_temp.stocks
--See column A...G in Raw_Data tab of Outputs workbook

--===================================================Windowing Function Analysis==============================================
--===================================================Lag Function==============================================
--Lag -
--This function returns the values of the previous row.

select ticker,date_,close,lag(close,1) over(partition by ticker) as yesterday_price from eb_temp.stocks;
--Here using lag we can display the yesterday’s closing price of the ticker. Lag is to be used with over function, inside the over function you can use partition or order by classes.
--See column A...D in Lag tab

select ticker,date_,close,lag(close,1) over(ORDER by concat(ticker,date_)) as yesterday_price from eb_temp.stocks;
--Order by default mode is ASC, you can change it to DESC like ORDER by concat(ticker,date_) DESC
--Here using lag we can display the yesterday’s closing price by using order by(concatenation of ticker and date_). Lag is to be used with over function, inside the over function you can use partition or order by classes.
--See column F...I in Lag tab

--===================================================Lead Function==============================================
--Lead -
--This function returns the values from the following rows.

--Now using the lead function, we will find that whether the following day’s closing price is higher or lesser than today’s and that can be done as follows.
select ticker,date_,close,
case (lead(close,1) over(partition by ticker) - close) > 0 
when true then "higher" 
when false then "lesser" 
end as Changes from eb_temp.stocks
--See column A...D in Lead tab

--Here we can use multiple windowing function in Over clause
select ticker,date_,close,
case (lead(close,1) over(partition by ticker order by concat(ticker,date_)) - close) > 0 
when true then "higher" 
when false then "lesser" 
end as Changes from eb_temp.stocks
--See column F...I in Lead tab


--===================================================FIRST_VALUE Function==============================================
--FIRST_VALUE -
--It returns the value of the first row from that window. With the below query, you can see the first row high price of the ticker for all the days.

select ticker,high,first_value(high) over(partition by ticker) as first_high from eb_temp.stocks
--See column A...C in FIRST_VALUE tab


--===================================================LAST_VALUE Function==============================================
--LAST_VALUE -
--It is the reverse of FIRST_VALUE. It returns the value of the last row from that window. With the below query, you can see the last row high price value of the ticker for all the days.

select ticker,high,last_value(high) over(partition by ticker) as Last_high from eb_temp.stocks
--See column A...C in LAST_VALUE tab

--==============================================Use of Over Clause with aggregate function==============================================
--==============================================Count with Over==============================================
--It returns the count of all the values for the expression written in the over clause. From the below query, we can find the number of rows present for each ticker.

select ticker,count(ticker) over(partition by ticker) as cnt from eb_temp.stocks
--See column A...B in Count with OVER tab

select distinct ticker,count(ticker) over(partition by ticker) as cnt from eb_temp.stocks
--See column D...E in Count with OVER tab


--==============================================SUM with Over==============================================
--It returns the sum of all the values for the expression written in the over clause. From the below query, we can find the sum of all the closing stock prices for that particular ticker.

select ticker,SUM(close) over(partition by ticker) as total from eb_temp.stocks
--See column A...B in SUM with OVER tab

select DISTINCT ticker,SUM(close) over(partition by ticker) as total from eb_temp.stocks
--See column D...E in SUM with OVER tab

--Finding running total
--For suppose let us take if you want to get running total of the volume_for_the_day for all the days for every ticker then you can do this with the below query.

select ticker,date_,volume_for_the_day,sum(volume_for_the_day) over(partition by ticker order by date_) as running_total from eb_temp.stocks
--See column G...J in SUM with OVER tab

--Finding the percentage of each row value
--Now let’s take a scenario where you need to find the percentage of the volume_for_the_day on the total volumes for that particular ticker and that can be done as follows.

select ticker,date_,volume_for_the_day,(volume_for_the_day*100/(sum(volume_for_the_day) over(partition by ticker))) as percentage from eb_temp.stocks
--See column L...O in SUM with OVER tab


--==============================================MIN with Over==============================================
--It returns the minimum value of the column for the rows in that over clause. From the below query, we can find the minimum closing stock price for each particular ticker.

select ticker, min(close) over(partition by ticker) as minimum from eb_temp.stocks
--See column A...B in MIN with OVER tab

select DISTINCT ticker, min(close) over(partition by ticker) as minimum from eb_temp.stocks
--See column D...E in MIN with OVER tab


--==============================================MAX with Over==============================================
--It returns the maximum value of the column for the rows in that over clause. From the below query, we can find the maximum closing stock price for each particular ticker.

select ticker, max(close) over(partition by ticker) as maximum from eb_temp.stocks
--See column A...B in MAX with OVER tab

select Distinct ticker, max(close) over(partition by ticker) as maximum from eb_temp.stocks
--See column D...E in MAX with OVER tab


--==============================================AVG with Over==============================================
--It returns the average value of the column for the rows that over clause returns. From the below query, we can find the average closing stock price for each particular ticker.

select ticker, avg(close) over(partition by ticker) as maximum from eb_temp.stocks
--See column A...B in AVG with OVER tab

select Distinct ticker, avg(close) over(partition by ticker) as maximum from eb_temp.stocks
--See column D...E in AVG with OVER tab


--===================================================Analytic Functions==============================================
--===================================================RANK Function====================================================
--RANK -
--The rank function will return the rank of the values as per the result set of the over clause. If two values are same then it will give the same rank to those 2 values and then for the next value, the sub-sequent rank will be skipped.

--The below query will rank the closing prices of the stock for each ticker.

select ticker,close,rank() over(partition by ticker order by close) as closing from eb_temp.stocks
--See column A...C in RANK tab


--===================================================Row_number Function====================================================
--Row_number -
--Row_number will return the continuous sequence of numbers for all the rows of the result set of the over clause.

--From the below query, you will get the ticker, closing price and its row number for each ticker.

select ticker,close,row_number() over(partition by ticker order by close) as num from eb_temp.stocks
--See column A...C in Row_number tab


--===================================================Dense_rank Function====================================================
--Dense_rank -
--It is same as the rank() function but the difference is if any duplicate value is present then the rank will not be skipped for the subsequent rows. Each unique value will get the ranks in a sequence.

--The below query will rank the closing prices of the stock for each ticker.

select ticker,close,dense_rank() over(partition by ticker order by close) as closing from eb_temp.stocks
--See column A...C in Dense_rank tab



--===================================================Cume_dist Function====================================================
--Cume_dist -
--It returns the cumulative distribution of a value. It results from 0 to 1. For suppose if the total number of records are 10 then for the 1st row the cume_dist will be 1/10 and for the second 2/10 and so on till 10/10

--This cume_dist will be calculated in accordance with the result set returned by the over clause. The below query will result in the cumulative of each record for every ticker.

select ticker,cume_dist() over(partition by ticker order by close) as cummulative from eb_temp.stocks
--See column A...B in Cume_dist tab



--===================================================Percent_rank Function====================================================
--Percent_rank -
--It returns the percentage rank of each row within the result set of over clause. Percent_rank is calculated in accordance with the rank of the row and the calculation is as follows (rank-1)/(total_rows_in_group – 1). If the result set has only one row then the percent_rank will be 0.

--The below query will calculate the percent_rank for every row in each partition.

select ticker,close,percent_rank() over(partition by ticker order by close) as closing from eb_temp.stocks
--See column A...C in Percent_rank tab



--===================================================Ntile Function====================================================
--Ntile -
--It returns the bucket number of the particular value. For suppose if you say Ntile(5) then it will create 5 buckets based on the result set of the over clause after that it will place the first 20% of the records in the 1st bucket and so on till 5th bucket.

--The below query will create 5 buckets for every ticker and the first 20% records for every ticker will be in the 1st bucket and so on.

select ticker,ntile(5) over(partition by ticker order by close ) as bucket from eb_temp.stocks
--See column A...B in Ntile tab

select ticker,ntile(10) over(partition by ticker order by close ) as bucket from eb_temp.stocks
--See column D...E in Ntile tab
